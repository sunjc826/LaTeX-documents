December 2021

## Notation
In backtick-quoted code, equality checking, comparisons etc follow the Java style, e.g. `==` for equality, `<=,>=` for comparisons.
In dollar-quoted maths (KaTeX), equality checking, comparisons will follow usual mathematical notation.

Furthermore, a mathematical statement like $x=1$, would in code form be `x==1`. This is to be taken as a declaration that $x$ equals $1$ is a true statement, unless it is explicitly mentioned for e.g., that `x==1` does not hold, or that `x==1` evaluates to false.

Assignment in maths is denoted by $\gets$.

## Mutual Exclusion Problem
### Peterson's Algorithm

#### Mutual Exclusion Property
In the proof by contradiction, we consider the most recent executions of both processes. For instance, process 0 is in the CS (critical section), so the most recent lines of code executed (barring the CS itself) is `RequestCS(0)`. Similarly, since process 1 is in the CS, the most recent lines of code executed falls under `RequestCS(1)`.

Note that we did not claim that the most recent executions **across all processes** are `RequestCS(0)` and `RequestCS(1)`. It could, for example be in the following order:
1. P(rocess)0: `RequestCS(0)`
2. P1: `RequestCS(1)`
3. P0: Enter CS
4. P0: `ReleaseCS(0)`
5. P0: `RequestCS(0)`
6. P0: Enter CS
7. P1: Enter CS
So, clearly, the most recent lines executed outside of the CS are actually `ReleaseCS(0)` and `RequestCS(0)`.

But the point is, when P0 and P1 are in the CS, the most recent lines executed by $P_i$ must be `RequestCS(i)`.

With this detail established, we continue on with the proof.

The variable `turn` can only take the values in $\{0,1\}$, and we can prove this since `turn` is initialized to $0\in \{0,1\}$ and in the program, `turn` can only ever be assigned to `0` or `1`.

We transcribe the proof given in lecture slides. By symmetry, we only discuss the case where `turn == 0`. (Note that when we say P0 executed `turn=1` we are referring to the most recent execution of that line by P0; similarly for other commands.)

Before reaching the CS, P0 must first execute `turn=1` and P1 must first execute `turn=0`. Since `turn==0`, of these 2 assignments, the (globally) most recent assignment must be `turn=0` by P1. Hence, between the time P1 executes `turn=0` and **now**(i.e. both P0, P1 in CS), P0 will not execute any line before `turn=1` (inclusive).

Hence, when P0 reaches the while loop, we are assured that `turn==0` as there are no further assignments to `turn`. Furthermore, for P1 to enter the CS, we must have `wantCS[0]==true` evaluating to false, i.e. `wantCS[0]==false`.

Here, we introduce arrow notation as follows. Event A $\rightarrow$ event B means that A took place prior to B.
P0 `wantCS[0]=true` $\rightarrow$ P0: `turn==1` $\rightarrow$ P1: `turn=0` $\rightarrow$ P1: while loop
However, based on this timeline analysis, we see at the time of P1's while loop the most recent assignment to `wantCS[0]` was by P0, setting it to `true`, a contradiction. $\square$

#### Progress Property
Suppose at least one of P0 and P1 are waiting. Then the only reason P0 and P1 may not enter the CS is due to the while loop, since all other lines in `RequestCS` can be run in constant (in particular, bounded) time, i.e. it suffices to consider the case where a process is either
1. at the while loop if waiting, 
2. or completely outside `RequestCS` if not waiting.

Consider cases, where we split the cases by how many processes are waiting. The lecture slides seem to only consider the first case.

Case 1: Both processes are waiting.
Progress holds by the fact that it is not possible for `turn==0` and `turn==1` to both be true.

Case 2: Only P0 is waiting.
Since P1 is not waiting, P1 must either 
1. Amongst `RequestCS` and `ReleaseCS`, ran `ReleaseCS` more recently
2. Never ran `RequestCS` before
In either case, `wantCS[1]==false`, so that P0 can pass the while loop and enter the CS

Case 3: Symmetric to Case 2.

Hence progress. $\square$

#### No Starvation Property
WLOG, we show that if P0 is waiting, P0 will not be starved. It suffices to show that $\exists k\in\mathbb{N}$ such that at most $k$ *other* processes distinct from P0 (in this case P1) that can enter the CS before P0.

Similarly to the start of the proof of progress, we assume that P0 is at the while loop, where the loop condition evaluates to `true`. We claim that $k=1$ will suffice for the while loop to evaluate to false, allowing P0 to return from `RequestCS`.

If P1 has
1. Amongst `RequestCS` and `ReleaseCS`, ran `ReleaseCS` more recently
2. Never ran `RequestCS` before
then, as in progress, `wantCS[1]==false` and we are done.

If P1 ran `RequestCS` most recently, then by progress, either P0 or P1 must enter the CS. If P0 enters, we are done. If P1 enters, then P1 will eventually finish the CS, calling `RequestCS`. Then, `wantCS[1]==false` and we are done. $\square$

### Lamport's Bakery Algorithm
We note the following in the algorithm.
- Tuples `(queueNumber, id)` are ordered first by `queueNumber`, then `id`.
- In "get a number", $number[myid]\gets\max\{number[j] : 0\leq j<n\}+1$

#### Progress Property
Suppose a non-zero number of processes, say $1\leq k\leq n$ are waiting at `RequestCS`. Examining the code, we see that a process can only wait at one of the while loops in the second for loop.

Note that if a process is not waiting, i.e. $P\notin\{P_{i_1},\dots,P_{i_k}\}$, we can simply assume that it is completely outside `RequestCS` such that `choosing[process_id]==false` and `number[process_id]==0`.

Suppose a process, $P = P_i\in \{P_{i_1},\dots,P_{i_k}\}$ is one of the waiting processes. We consider cases.
1. P is waiting at `while (choosing[j]==true)` for some $j$. In this case, process $P_j$, which we will write as Pj can always complete the "get a number" portion, such that in a finite amount of time, `choosing[j]=false` executes. Then, `choosing[j]==true` evaluates to false under process P, or otherwise, we must have the assignment `choosing[j]=true`, which would mean Pj entered the CS, left the CS, and called `RequestCS`. While the 2nd case should not happen based on the code, even if it does, we already have progress.
2. P is waiting at `while (number[j]!=0 && Smaller(number[j], j, number[i], i)`. In this case, we claim that we can find some $P_i\in \{P_{i_1},\dots,P_{i_k}\}$ such that $\forall j\in\{1,\dots,n\}$, `number[j]!=0 && Smaller(number[j], j, number[i], i)` evaluates to `true`, which we will prove below.

**Lemma.** $\exists i\in\{1,\dots,k\}, \forall j\in\{1,\dots,n\}$, `number[j]!=0 && Smaller(number[j], j, number[i], i)` evaluates to true.

If $j\in \{1,\dots,n\}\setminus\{i_1,\dots,i_k\}$, then `number[j]==0` and so `number[j]!=0` evaluates to `false`.

Otherwise, amongst the elements `(number[index], index)` indexed by $\{i_1,\dots,i_k\}$, there must exist a minimal element, since there are finitely many elements. If $i_l$ indexes a minimal element, then process $P=P_{i_l}$ will have `Smaller(number[j], j, number[i_l], i_l)` evaluate to `false` for each $j\in\{1,\dots,n\}$.

Furthermore, we claim that even if more processes call `RequestCS`, P will still be the "smallest". This is true by examining how "get a number" is guaranteed to assign a new process a queue number of at least $number[i_l] + 1$.

Hence such a process P will pass both while loops at each iteration of the for loop and enter the CS. (in particular, we have shown that at least one waiting process can enter the CS.) $\square$

#### No Starvation Property
We fix a process of id $i\in\{1,\dots,n\}$, and that $P=P_i$ is waiting to enter the CS. We claim that P will not be starved.

As proven in progress, P will not be blocked by `while (choosing[j] == true)`.

At the current point of discussion, we sort the elements $\{(number[j], j) : 1\leq j\leq n \land number[j]\neq 0\}$. Then suppose $i$ is at position $p$. Then we claim that at most (in fact, exactly) $p-1$ processes can enter the CS before P does, i.e. $k = p-1$.

WLOG, we assume that all $p-1$ processes ranked ahead of $i$ by our ordering have entered and left the CS. At this point, regardless of what the other processes do, $(number[i], i) = \min\{(number[j], j) : 1\leq j\leq n \land number[j]\neq 0\}$, since "get a number", as discussed in progress, will grant any process entering `RequestCS` a queue number $\geq number[i] + 1$.

Hence, P will not be blocked by `while (number[j]!=0 && Smaller(number[j], j, number[i], i)` for any $j\in\{1,\dots,n\}$. $\square$

#### Mutual Exlusion Property


