December 2021

## Notation
In backtick-quoted code, equality checking, comparisons etc follow the Java style, e.g. `==` for equality, `<=,>=` for comparisons.
In dollar-quoted maths, equality checking, comparisons will follow usual mathematical notation.

Furthermore, a mathematical statement like $x=1$, would in code form be `x==1`. This is to be taken as a declaration that $x$ equals $1$ is a true statement, unless it is explicitly mentioned for e.g., that `x==1` does not hold, or that `x==1` evaluates to false.

## Mutual Exclusion Problem
### Peterson's Algorithm

#### Mutual Exclusion Property
In the proof by contradiction, we consider the most recent executions of both processes. For instance, process 0 is in the CS (critical section), so the most recent lines of code executed (barring the CS itself) is `RequestCS(0)`. Similarly, since process 1 is in the CS, the most recent lines of code executed falls under `RequestCS(1)`.

Note that we did not claim that the most recent executions **across all processes** are `RequestCS(0)` and `RequestCS(1)`. It could, for example be in the following order:
1. P(rocess)0: `RequestCS(0)`
2. P1: `RequestCS(1)`
3. P0: Enter CS
4. P0: `ReleaseCS(0)`
5. P0: `RequestCS(0)`
6. P0: Enter CS
7. P1: Enter CS
So, clearly, the most recent lines executed outside of the CS are actually `ReleaseCS(0)` and `RequestCS(0)`.

But the point is, when P0 and P1 are in the CS, the most recent lines executed by $P_i$ must be `RequestCS(i)`.

With this detail established, we continue on with the proof.

The variable `turn` can only take the values in $\{0,1\}$, and we can prove this since `turn` is initialized to $0\in \{0,1\}$ and in the program, `turn` can only ever be assigned to `0` or `1`.

We transcribe the proof given in lecture slides. By symmetry, we only discuss the case where `turn == 0`. (Note that when we say P0 executed `turn=1` we are referring to the most recent execution of that line by P0; similarly for other commands.)

Before reaching the CS, P0 must first execute `turn=1` and P1 must first execute `turn=0`. Since `turn==0`, of these 2 assignments, the (globally) most recent assignment must be `turn=0` by P1. Hence, between the time P1 executes `turn=0` and **now**(i.e. both P0, P1 in CS), P0 will not execute any line before `turn=1` (inclusive).

Hence, when P0 reaches the while loop, we are assured that `turn==0` as there are no further assignments to `turn`. Furthermore, for P1 to enter the CS, we must have `wantCS[0]==true` evaluating to false, i.e. `wantCS[0]==false`.

Here, we introduce arrow notation as follows. Event A $\rightarrow$ event B means that A took place prior to B.
P0 `wantCS[0]=true` $\rightarrow$ P0: `turn==1` $\rightarrow$ P1: `turn=0` $\rightarrow$ P1: while loop
However, based on this timeline analysis, we see at the time of P1's while loop the most recent assignment to `wantCS[0]` was by P0, setting it to `true`, a contradiction. $\square$

#### Progress Property
Suppose at least one of P0 and P1 are waiting. Then the only reason P0 and P1 may not enter the CS is due to the while loop, since all other lines in `RequestCS` can be run in constant (in particular, bounded) time, i.e. it suffices to consider the case where a process is either
1. at the while loop if waiting, 
2. or completely outside `RequestCS` if not waiting.

Consider cases, where we split the cases by how many processes are waiting. The lecture slides seem to only consider the first case.

Case 1: Both processes are waiting.
Progress holds by the fact that it is not possible for `turn==0` and `turn==1` to both be true.

Case 2: Only P0 is waiting.
Since P1 is not waiting, P1 must either 
1. Amongst `RequestCS` and `ReleaseCS`, ran `ReleaseCS` more recently
2. Never ran `RequestCS` before
In either case, `wantCS[1]==false`, so that P0 can pass the while loop and enter the CS

Case 3: Symmetric to Case 2.

Hence progress. $\square$

#### No Starvation Property
WLOG, we show that if P0 is waiting, P0 will not be starved. It suffices to show that $\exists k\in\mathbb{N}$ such that at most $k$ *other* processes distinct from P0 (in this case P1) that can enter the CS before P0.

Similarly to the start of the proof of progress, we assume that P0 is at the while loop, where the loop condition evaluates to `true`. We claim that $k=1$ will suffice for the while loop to evaluate to false, allowing P0 to return from `RequestCS`.

If P1 has
1. Amongst `RequestCS` and `ReleaseCS`, ran `ReleaseCS` more recently
2. Never ran `RequestCS` before
then, as in progress, `wantCS[1]==false` and we are done.

If P1 ran `RequestCS` most recently, then by progress, either P0 or P1 must enter the CS. If P0 enters, we are done. If P1 enters, then P1 will eventually finish the CS, calling `RequestCS`. Then, `wantCS[1]==false` and we are done. $\square$

### Lamport's Bakery Algorithm

